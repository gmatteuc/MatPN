function [ PI, Zp, Zc, Rp, Rc ] = get_pattern_index( tuning_curve_grating,tuning_curve_plaid )
% [ PI, Zp, Zc, Rp, Rc ] = get_pattern_index( tuning_curve_grating,tuning_curve_plaid )
% compute patterna and component predictions given two tuning curves

%--------------------------------------------------------------------------
% Component neurons: response to plaid is SUM of responses to two
% components presented separately
% The predicted response for the component model was generated by taking
% the sum of two grating tuning curves, each shifted by ...

% set spontaneous firing rate to zero
Spont_FR_1=0;
Spont_FR_2=Spont_FR_1;
Spont_FR=Spont_FR_1;

% re-assign names
tun_vector=tuning_curve_grating'+ 0.0000001*rand(size(tuning_curve_grating'));
tun_vector_p=tuning_curve_plaid'+ 0.0000001*rand(size(tuning_curve_plaid'));

% set plaid response
Resp_Plaid=tun_vector_p;

% set grating responses 1 and 2
Resp_Grat1_raw = circshift(tun_vector',-2)';
Resp_Grat2_raw = circshift(tun_vector',2)';

Resp_Comp1 = Resp_Grat1_raw - Spont_FR_1; % subtract firing rate from response to grating1
Resp_Comp2 = Resp_Grat2_raw - Spont_FR_2; % subtract firing rate from response to grating2
CDS_prediction_part = Resp_Comp1 + Resp_Comp2; % CDS response as sum of the two grating responses w/o firing rate
CDS_prediction = (CDS_prediction_part + Spont_FR)/2; % CDS response as sum of the two grating responses WITH firing rate

% Pattern neurons: response to plaid is equal to response to single grating with same direction:
% ----> assuming Resp_Grat1_raw being response to single grating with direction equal to plaid

Resp_Grat3_raw=tun_vector;
PDS_prediction = Resp_Grat3_raw; % pattern prediction

%% calculate the partial correlation to classify neurons as PDS or CDS:

% 1) calculate correlation of response to CDS, PDS, and correlation between CDS and PDS
rc = corr(Resp_Plaid',CDS_prediction');
rp = corr(Resp_Plaid',PDS_prediction');
rcp = corr(PDS_prediction',CDS_prediction');

% 2) calculate partial correlation to make the two predictions independent
Rp = (rp-rc*rcp)/sqrt((1-rc^2)*(1-rcp^2)); % Pattern
Rc = (rc-rp*rcp)/sqrt((1-rp^2)*(1-rcp^2)); % Component

% 3) fisher transform them
Zp=0.5*(log((1+Rp)/(1-Rp)))/sqrt(1/(12-3));
Zc=0.5*(log((1+Rc)/(1-Rc)))/sqrt(1/(12-3));

% 4) compute "pattern index" (Wang, Movshon 2015)
PI=Zp-Zc;

end

